/**
 * 通用的 barrel（index.ts）自动生成工具函数
 *
 * 支持两种导出模式：
 * - 'named':   export * from './xxx'          （utils、hooks/internal 等具名导出）
 * - 'default': export { default as xxx } from './xxx'（hooks 顶层、components 等默认导出）
 *
 * 支持递归处理子目录：自动为含 .ts 文件的子目录生成 index.ts，并在上层 export *
 */
import fs from 'fs'
import path from 'path'

const HEADER = '// Auto-generated by scripts/gen-barrel.ts — DO NOT EDIT'

export type ExportMode = 'named' | 'default'

export interface BarrelOptions {
  /** 目录绝对路径 */
  dir: string
  /** 顶层 .ts 文件的导出模式 */
  fileExportMode: ExportMode
  /** 日志前缀，如 'components' */
  label: string
  /**
   * components 模式：扫描子目录（含 index.ts 或 index.vue）作为顶层导出
   * 设为 true 时忽略顶层 .ts 文件，只看子目录
   */
  dirOnly?: boolean
}

/** 获取目录下所有 .ts 文件名（不含 index.ts），返回不带后缀的名称列表 */
function getTsFiles(dir: string): string[] {
  return fs.readdirSync(dir, { withFileTypes: true })
    .filter(d => d.isFile() && d.name.endsWith('.ts') && d.name !== 'index.ts')
    .map(d => d.name.replace(/\.ts$/, ''))
    .sort()
}

/** 获取含 .ts 文件的子目录名列表 */
function getSubDirsWithTs(dir: string): string[] {
  return fs.readdirSync(dir, { withFileTypes: true })
    .filter(d => d.isDirectory())
    .map(d => d.name)
    .filter(name => {
      const sub = path.join(dir, name)
      const hasTsFiles = fs.readdirSync(sub, { withFileTypes: true })
        .some(f => f.isFile() && f.name.endsWith('.ts') && f.name !== 'index.ts')
      return hasTsFiles
    })
    .sort()
}

/** 获取含 index.ts 或 index.vue 的子目录名列表（用于 components） */
function getComponentDirs(dir: string): string[] {
  return fs.readdirSync(dir, { withFileTypes: true })
    .filter(d => d.isDirectory())
    .map(d => d.name)
    .filter(name =>
      fs.existsSync(path.join(dir, name, 'index.ts')) ||
      fs.existsSync(path.join(dir, name, 'index.vue'))
    )
    .sort()
}

/** 根据模式生成一行导出语句 */
function makeExportLine(name: string, mode: ExportMode): string {
  return mode === 'default'
    ? `export { default as ${name} } from './${name}'`
    : `export * from './${name}'`
}

/** 为指定子目录生成 index.ts（统一用 export *） */
function genSubDirIndex(parentDir: string, subDirName: string, label: string): void {
  const subDir = path.join(parentDir, subDirName)
  const files = getTsFiles(subDir)

  const lines = [HEADER, '', ...files.map(f => `export * from './${f}'`), '']
  fs.writeFileSync(path.join(subDir, 'index.ts'), lines.join('\n'), 'utf-8')
  console.log(`  └─ Generated ${label}/${subDirName}/index.ts (${files.length} exports)`)
}

/**
 * 生成 barrel index.ts 并递归处理子目录
 */
export function generateBarrel(options: BarrelOptions): void {
  const { dir, fileExportMode, label, dirOnly = false } = options
  const outputFile = path.join(dir, 'index.ts')
  const exportLines: string[] = []

  if (dirOnly) {
    // ---- components 模式：只扫子目录 ----
    const dirs = getComponentDirs(dir)
    for (const name of dirs) {
      exportLines.push(makeExportLine(name, fileExportMode))
    }
    const lines = [HEADER, '', ...exportLines, '']
    fs.writeFileSync(outputFile, lines.join('\n'), 'utf-8')
    console.log(`✅ Generated ${label}/index.ts (${dirs.length} modules: ${dirs.join(', ')})`)
  } else {
    // ---- hooks / utils 模式：顶层文件 + 子目录 ----
    const files = getTsFiles(dir)
    const subDirs = getSubDirsWithTs(dir)

    for (const name of files) {
      exportLines.push(makeExportLine(name, fileExportMode))
    }
    for (const name of subDirs) {
      exportLines.push(`export * from './${name}'`)
    }

    const lines = [HEADER, '', ...exportLines, '']
    fs.writeFileSync(outputFile, lines.join('\n'), 'utf-8')
    console.log(`✅ Generated ${label}/index.ts (${files.length} files + ${subDirs.length} sub-dirs)`)

    // 递归生成子目录的 index.ts
    for (const sub of subDirs) {
      genSubDirIndex(dir, sub, label)
    }
  }
}
